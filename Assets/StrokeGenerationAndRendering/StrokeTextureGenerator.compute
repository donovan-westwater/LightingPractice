// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSGatherStrokes
#pragma kernel CSApplyStroke
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2DArray<float4> _Results : register(u0);
int resolution;
SamplerState sampler_LinearClamp;

//THE GOAL IS TO MAKE A SINGLE STROKE ATOMIC!
//This way we know that a stroke has not been partially applied
float goalVal = 1.995;//0.875;
globallycoherent RWStructuredBuffer<float> mipGoals;
globallycoherent RWStructuredBuffer<uint> mipPixels;
uint rng_state;

struct Stroke {
    float2 normPos;
    float normLength;
    //Add more strange stroke behavior later via compliler derectives in functions/ this struct
};
RWStructuredBuffer<Stroke> finalStroke: register(u1);
groupshared float maxCanidateToneVal = 0.0;
//Found here:https://gist.github.com/keijiro/ee7bc388272548396870#file-prng-cginc-L1
//VERY COMMON PSUEDO RANDOM FUNCTION!
float nrand(float2 uv)
{
    return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453);
}
//From this article: https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/
uint rand_pcg()
{
    uint state = rng_state;
    rng_state = rng_state * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}
uint pcg_hash(uint input)
{
    uint state = input * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}
float hash_rand(uint input) {
    uint r = pcg_hash(input);
    return (float)r * (1.0 / 4294967296.0);
}
float pcg_float() {
    uint r = rand_pcg();
    return (float)r * (1.0 / 4294967296.0);
}
Stroke StrokeRandomizer(float2 uv) {
    uint seed = (uint)uv.x + resolution * (uint)uv.y;
    float x = hash_rand(seed);
    seed = seed << 3;
    float y = hash_rand(seed);
    seed = ~seed;
    //seed = seed | 273809707u;
    float l = 0.3+0.2*hash_rand(seed); //(.3 - 1.0) range
    Stroke s;
    s.normPos = float2(x, y);
    s.normLength = l;
    return s;
}
[numthreads(1000,1,1)]
void CSGatherStrokes(uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupThreadID) {
    Stroke s = StrokeRandomizer(float2(id.x, id.y));
    //_Results[uint3(id.x % 256, id.x / 256, 0)] = float4(s.normLength, s.normPos.x, s.normPos.y, 1.0);
    //if (id.x == 0 && id.y == 0 && id.z == 0) finalStroke[0] = s;
    
    float toneSum = 0;
    for (int j = 7; j >= 0; j--) {
        int mipRes = resolution >> j;
        float totalPixels = (float)(mipRes * mipRes);
        //if (mipGoals[j] < goalVal) continue;
        uint2 pixelPos = uint2((uint)(s.normPos.x * mipRes), (uint)(s.normPos.y * mipRes));
        uint pixelLength = (uint)(mipRes * s.normLength);
        uint pixelsAdded = 0;
        for (int sc = 0; sc < pixelLength; sc++) {
            float newPixels = (float)(pixelsAdded + mipPixels[j]);
            float newToneAvg = (totalPixels - newPixels) / totalPixels;
            //if (newToneAvg < goalVal) break;
            if (_Results[uint3(pixelPos.x + sc, pixelPos.y, j)].r > .95
                && _Results[uint3(pixelPos.x + sc, pixelPos.y, j)].g > .95
                && _Results[uint3(pixelPos.x + sc, pixelPos.y, j)].b > .95) {
                pixelsAdded++;
            }
        }
        float newPixels = (float)(pixelsAdded + mipPixels[j]);
        float goalResult = (totalPixels - newPixels) / totalPixels;
        toneSum += goalResult;
    }
    toneSum /= 8.0;
    //Wait for all the candidates to be found before comparing?
    //AllMemoryBarrierWithGroupSync();
    if (toneSum > maxCanidateToneVal) {
        float og = 0.0;
        InterlockedExchange(maxCanidateToneVal, toneSum, og);
        InterlockedExchange(finalStroke[0].normLength, s.normLength,og);
        InterlockedExchange(finalStroke[0].normPos.x, s.normPos.x, og);
        InterlockedExchange(finalStroke[0].normPos.y, s.normPos.y, og);
        //finalStroke[0] = s;
    }
    
}
[numthreads(8, 8, 1)]
void CSApplyStroke(uint3 id : SV_DispatchThreadID) {
    //Take the currently selected final stroke and apply it!
    //if(resolution == 0)_Results[id.xyz] = float4(finalStroke[0].normLength, 0.0, 0.0, 1.0);
    for (int j = 7; j >= 0; j--) {
        int mipRes = resolution >> j;
        float totalPixels = (float)(mipRes * mipRes);
        uint2 pixelPos = uint2((uint)(finalStroke[0].normPos.x * mipRes), (uint)(finalStroke[0].normPos.y * mipRes));
        uint pixelLength = (uint)(mipRes * finalStroke[0].normLength);
        bool check = id.x >= pixelPos.x && id.x <= (pixelPos.x + pixelLength)
            && pixelPos.y == id.y;
        bool isPrevWhite = _Results[uint3(id.x, id.y, j)].r > .95
            && _Results[uint3(id.x, id.y, j)].g > .95
            && _Results[uint3(id.x, id.y, j)].b > .95;
        if (check) _Results[uint3(id.x, id.y, j)] = float4(0.0, 0.0, 1.0, 1.0);
        if (isPrevWhite && (_Results[uint3(id.x, id.y, j)].r < .95
            || _Results[uint3(id.x, id.y, j)].g < .95
            || _Results[uint3(id.x, id.y, j)].b < .95)) {
            InterlockedAdd(mipPixels[j], 1);
            float goalResult = (totalPixels - (float)mipPixels[j]) / totalPixels;
            float og = 0.0;
            InterlockedExchange(mipGoals[j], goalResult, og);
        }
    }
}
[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupThreadID)
{
    //Once we generate the Strokes, we check to see if any of the pixels lie on the stroke 
    // Assoiated with z and then add the pixel to the texture and increment the 

    Stroke s = StrokeRandomizer(float2(id.x, id.y));
    //AllMemoryBarrierWithGroupSync();
    for (int j = 7; j >= 0; j--) {
        //AllMemoryBarrierWithGroupSync();
        int mipRes = resolution >> j;
        if ((id.x > mipRes || id.y > mipRes)) _Results[uint3(id.x, id.y, j)] = 1.0;
        else {
            //_Results[uint3(id.x, id.y, j)] = float4(j / 7.0, (id.x & 15) / 15.0, (id.y & 15) / 15.0, 1.0);
            //Current Bug: Continue isn't being continued correctly
            if (mipGoals[j] < goalVal) continue; //BUG: goalVal doesn't match earlier assignment!!!!!!!!!
            uint2 pixelPos = uint2((uint)(s.normPos.x*mipRes), (uint)(s.normPos.y * mipRes));
            uint pixelLength = (uint)(mipRes * s.normLength);
            uint endPoint = pixelPos.x + pixelLength;
            endPoint = clamp(endPoint, 0u, mipRes);
            pixelLength = endPoint - pixelPos.x;
            //InterlockedAdd(mipPixels[j], pixelLength);
            //float totalPixels = (float)(mipRes * mipRes);
            //float goalResult = (totalPixels - (float)mipPixels[j]) / totalPixels;
            //float og = 0.0;
            //InterlockedExchange(mipGoals[j], goalResult, og);
            //InterlockedExchange(mipGoals[j], goalVal, og);
            //if (goalResult < goalVal) continue;
            //if(mipGoals[j] < goalVal) break;
            for (int sc = 0; sc < pixelLength; sc++) {
                float totalPixels = (float)(mipRes * mipRes);
                float goalResult = (totalPixels - (float)mipPixels[j]) / totalPixels;
                if (goalResult < goalVal) break;
                if (_Results[uint3(pixelPos.x + sc, pixelPos.y, j)].r > .95
                    && _Results[uint3(pixelPos.x + sc, pixelPos.y, j)].g > .95
                    && _Results[uint3(pixelPos.x + sc, pixelPos.y, j)].b > .95) {
                    InterlockedAdd(mipPixels[j], 1);
                    goalResult = (totalPixels - (float)mipPixels[j]) / totalPixels;
                    float og = 0.0;
                    InterlockedExchange(mipGoals[j], goalResult, og);
                }
                //InterlockedAdd(mipPixels[j], 1);//mipPixels[j]++;            
                float pixelPct = (float)mipPixels[j] / totalPixels; //DEBUG VAR
                _Results[uint3(pixelPos.x + sc, pixelPos.y, j)] = float4(pixelPct, 0.0, 1.0, 1.0);
            }
            
        }
        //AllMemoryBarrierWithGroupSync();
    }
    //_Results[uint3(id.x,id.y,0)] = float4(0, (id.x & 15) / 15.0, (id.y & 15) / 15.0, 1.0);
    //_Results[uint3(id.x, id.y, 1)] = float4(1.0, 0.0,0.0, 0.0);
    //if (id.z > 0)_Results[uint3(id.x, id.y, id.z)] = float4(0, 0, 0, 0);
    
}
